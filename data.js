// ============================================
// DATOS DE EJERCICIOS (CURRICULUM COMPLETO)
// 208 Ejercicios Totales (92 Completos + 116 Desafíos)
// ============================================

const exercisesData = [
    // --- PRINCIPIANTE (60 ejercicios) ---
    // IDs 1-20: Módulo 1 (Indentación, Intro, Variables, Operadores, Condicionales)
    { id: 1, lessonId: 1, title: 'Indentar un Método', description: 'Indenta correctamente el código.', difficulty: 'easy', starterCode: 'public class Ejemplo {\npublic static void main(String[] args) {\nSystem.out.println("Hola");\n}\n}', solution: 'public class Ejemplo {\n    public static void main(String[] args) {\n        System.out.println("Hola");\n    }\n}', hint: 'Cada nivel dentro de llaves { } debe tener 4 espacios de indentación. El método main está dentro de la clase (4 espacios), y el println está dentro del método (8 espacios).', validation: { checkIndentation: true, checkSyntax: true, requiredKeywords: ['public', 'class', 'static', 'void', 'main'], indentationSpaces: 4 } },
    { id: 2, lessonId: 1, title: 'Código con If-Else', description: 'Indenta if-else.', difficulty: 'medium', starterCode: 'if (edad >= 18) {\nSystem.out.println("Mayor");\n} else {\nSystem.out.println("Menor");\n}', solution: 'if (edad >= 18) {\n    System.out.println("Mayor");\n} else {\n    System.out.println("Menor");\n}', hint: 'El contenido dentro del if y del else debe estar indentado con 4 espacios. Las llaves de apertura van en la misma línea que if y else.', validation: { checkIndentation: true, requiredKeywords: ['if', 'else'] } },
    { id: 3, lessonId: 1, title: 'Múltiples Métodos', description: 'Indenta clase con 2 métodos.', difficulty: 'medium', starterCode: 'class P {\nvoid a() {\nSystem.out.println("a");\n}\nvoid b() {\nSystem.out.println("b");\n}\n}', solution: 'class P {\n    void a() {\n        System.out.println("a");\n    }\n\n    void b() {\n        System.out.println("b");\n    }\n}', hint: 'Los métodos van indentados 4 espacios (están dentro de la clase). El contenido de cada método va indentado 8 espacios. Deja una línea vacía entre métodos.', validation: { checkIndentation: true, requiredKeywords: ['void'] } },
    { id: 4, lessonId: 1, title: 'Bucle Anidado', description: 'Indenta for anidado y agrega espacios correctos.', difficulty: 'hard', starterCode: 'for(int i=0;i<5;i++){\nif(i%2==0){\nSystem.out.println(i);\n}\n}', solution: 'for (int i = 0; i < 5; i++) {\n    if (i % 2 == 0) {\n        System.out.println(i);\n    }\n}', hint: 'Debes hacer DOS cosas: 1) Indentar correctamente (if dentro del for = 4 espacios, println dentro del if = 8 espacios). 2) Agregar espacios: después de "for", alrededor de operadores (i = 0, i < 5, i++, i % 2 == 0).', validation: { checkIndentation: true, requiredKeywords: ['for', 'if'] } },
    { id: 5, lessonId: 2, title: 'Hola Mundo', description: 'Escribe programa "Hola, Java!".', difficulty: 'easy', starterCode: '', solution: 'public class Hola {\n    public static void main(String[] args) {\n        System.out.println("Hola, Java!");\n    }\n}', hint: 'Crea una clase pública con el método main. Usa System.out.println() para imprimir "Hola, Java!" (con coma y signo de exclamación).', validation: { checkSyntax: true, mustContain: 'Hola, Java!' } },
    { id: 6, lessonId: 2, title: 'Múltiples Líneas', description: 'Imprime 2 líneas.', difficulty: 'easy', starterCode: 'public class M {\npublic static void main(String[] args) {\n//...\n}\n}', hint: 'Reemplaza el comentario //... con dos llamadas a System.out.println(), una para cada línea. Cada println imprime en una línea nueva.', solution: 'System.out.println("Línea 1");\n        System.out.println("Línea 2");', validation: { mustContain: 'println', minLines: 2 } },
    { id: 7, lessonId: 2, title: 'Print vs Println', description: 'Usa print y println.', difficulty: 'medium', starterCode: '', solution: 'System.out.print("Hola ");\nSystem.out.println("Mundo");', hint: 'print() imprime sin salto de línea, println() imprime con salto de línea. Usa print para "Hola " (con espacio) y println para "Mundo".', validation: { requiredKeywords: ['print', 'println'] } },
    { id: 8, lessonId: 2, title: 'Printf', description: 'Usa printf para edad.', difficulty: 'hard', starterCode: 'int e = 25;', hint: 'printf permite formatear texto. Usa %d como marcador para números enteros: System.out.printf("Edad: %d", e);', solution: 'System.out.printf("Edad: %d", e);', validation: { requiredKeywords: ['printf', '%d'] } },
    { id: 9, lessonId: 3, title: 'Var Int', description: 'Declara edad = 25.', difficulty: 'easy', starterCode: '', solution: 'int edad = 25;', hint: 'Declara una variable entera con: tipo nombreVariable = valor; Ejemplo: int edad = 25;', validation: { requiredKeywords: ['int'], mustDeclare: 'edad' } },
    { id: 10, lessonId: 3, title: 'Var String', description: 'Declara nombre.', difficulty: 'easy', starterCode: '', solution: 'String nombre = "Ana";', hint: 'Los textos en Java se declaran con String (con S mayúscula). El valor va entre comillas dobles: String nombre = "Ana";', validation: { requiredKeywords: ['String'], mustDeclare: 'nombre' } },
    { id: 11, lessonId: 3, title: 'Casting', description: 'Double a int.', difficulty: 'medium', starterCode: 'double d = 9.99;', solution: 'int i = (int) d;', hint: 'Para convertir un double a int, usa casting: int i = (int) nombreVariable; Esto trunca los decimales.', validation: { requiredKeywords: ['(int)'] } },
    { id: 12, lessonId: 3, title: 'PI Constante', description: 'final double PI.', difficulty: 'hard', starterCode: '', solution: 'final double PI = 3.14159;', hint: 'Las constantes se declaran con final. Por convención, van en MAYÚSCULAS: final double PI = 3.14159;', validation: { requiredKeywords: ['final', 'PI'] } },
    { id: 13, lessonId: 4, title: 'Suma', description: '10 + 5.', difficulty: 'easy', starterCode: 'int a=10, b=5;', solution: 'int s = a + b;', hint: 'Crea una variable para guardar el resultado de la suma: int s = a + b;', validation: { requiredKeywords: ['+'] } },
    { id: 14, lessonId: 4, title: 'Módulo', description: 'Resto de 17 % 2.', difficulty: 'medium', starterCode: '', solution: 'int r = 17 % 2;', hint: 'El operador % (módulo) devuelve el resto de una división: int r = 17 % 2; (resultado: 1)', validation: { requiredKeywords: ['%'] } },
    { id: 15, lessonId: 4, title: 'AND Lógico', description: 'A && B.', difficulty: 'medium', starterCode: '', solution: 'boolean result = a && b;', hint: 'El operador && (AND) devuelve true solo si ambas condiciones son verdaderas: boolean result = a && b;', validation: { requiredKeywords: ['&&'] } },
    { id: 16, lessonId: 4, title: 'Ternario', description: 'Edad >= 18 ? "A" : "M".', difficulty: 'hard', starterCode: '', solution: 'String status = (e >= 18) ? "A" : "M";', hint: 'El operador ternario es un if-else compacto: variable = (condición) ? valorSiTrue : valorSiFalse;', validation: { requiredKeywords: ['?', ':'] } },
    { id: 17, lessonId: 5, title: 'If simple', description: 'Si x > 0 imprimir P.', difficulty: 'easy', starterCode: 'if(x > 0) { }', solution: 'if (x > 0) {\n    System.out.println("P");\n}', hint: 'Agrega System.out.println("P"); dentro de las llaves del if. Recuerda indentar con 4 espacios.', validation: { requiredKeywords: ['if'] } },
    { id: 18, lessonId: 5, title: 'If-Else Par', description: 'Par o Impar.', difficulty: 'medium', starterCode: '', solution: 'if (n % 2 == 0) {\n    System.out.println("Par");\n} else {\n    System.out.println("Impar");\n}', hint: 'Un número es par si n % 2 == 0. Usa if-else: si es par imprime "Par", si no imprime "Impar".', validation: { requiredKeywords: ['if', 'else'] } },
    { id: 19, lessonId: 5, title: 'Else If Nota', description: 'A, B o F.', difficulty: 'medium', starterCode: '', solution: 'if (n >= 90) s="A"; else if (n >= 70) s="B"; else s="F";', hint: 'Usa if-else if-else para múltiples condiciones: si n >= 90 es "A", si n >= 70 es "B", si no es "F".', validation: { requiredKeywords: ['else if'] } },
    { id: 20, lessonId: 5, title: 'Condición Compleja', description: 'A && (B || C).', difficulty: 'hard', starterCode: '', solution: 'if (a && (b || c)) { }', hint: 'Combina operadores lógicos: && (AND) y || (OR). Usa paréntesis para agrupar: if (a && (b || c))', validation: { requiredKeywords: ['&&', '||'] } },

    // IDs 21-40: Módulo 2 (Bucles, Switch, Scanner avanzado)
    { id: 21, lessonId: 6, title: 'While 1 a 5', description: 'Imprime 1 a 5 con while.', difficulty: 'easy', starterCode: 'int i = 1;', solution: 'while (i <= 5) {\n    System.out.println(i);\n    i++;\n}', hint: 'Usa while (condición) { }. Dentro del bucle imprime i y luego incrementa i++ para evitar bucle infinito.', validation: { requiredKeywords: ['while'] } },
    { id: 22, lessonId: 6, title: 'For Descendente', description: 'Imprime 10 a 1.', difficulty: 'easy', starterCode: '', solution: 'for (int i = 10; i >= 1; i--) {\n    System.out.println(i);\n}', hint: 'Inicia en 10, la condición es i >= 1, y decrementa con i--.', validation: { requiredKeywords: ['for'] } },
    { id: 23, lessonId: 6, title: 'Do-While', description: 'Ejecuta al menos una vez.', difficulty: 'medium', starterCode: '', solution: 'int i = 0;\ndo {\n    System.out.println(i);\n    i++;\n} while (i < 3);', hint: 'do-while ejecuta el bloque primero y luego verifica la condición. Sintaxis: do { } while (condición);', validation: { requiredKeywords: ['do', 'while'] } },
    { id: 24, lessonId: 6, title: 'Break en Bucle', description: 'Sale cuando i == 5.', difficulty: 'medium', starterCode: 'for (int i = 1; i <= 10; i++) {\n    // ...\n}', solution: 'for (int i = 1; i <= 10; i++) {\n    if (i == 5) break;\n    System.out.println(i);\n}', hint: 'Usa break para salir del bucle. Verifica con if si i == 5 y ejecuta break.', validation: { requiredKeywords: ['break'] } },
    { id: 25, lessonId: 6, title: 'Continue en Bucle', description: 'Salta pares.', difficulty: 'medium', starterCode: '', solution: 'for (int i = 1; i <= 5; i++) {\n    if (i % 2 == 0) continue;\n    System.out.println(i);\n}', hint: 'continue salta a la siguiente iteración. Si i es par (i % 2 == 0), usa continue para saltarlo.', validation: { requiredKeywords: ['continue'] } },
    { id: 26, lessonId: 6, title: 'Bucle Anidado Tabla', description: 'Tabla del 2 y 3.', difficulty: 'hard', starterCode: '', solution: 'for (int i = 2; i <= 3; i++) {\n    for (int j = 1; j <= 5; j++) {\n        System.out.println(i + " x " + j + " = " + (i * j));\n    }\n}', hint: 'Usa dos bucles for anidados. El externo para las tablas (2 y 3), el interno para los multiplicadores (1 a 5).', validation: { requiredKeywords: ['for'] } },
    { id: 27, lessonId: 6, title: 'Suma con While', description: 'Suma 1 a 100.', difficulty: 'medium', starterCode: '', solution: 'int suma = 0;\nint i = 1;\nwhile (i <= 100) {\n    suma += i;\n    i++;\n}\nSystem.out.println(suma);', hint: 'Inicializa suma en 0. En cada iteración suma += i. No olvides incrementar i.', validation: { requiredKeywords: ['while', '+='] } },
    { id: 28, lessonId: 6, title: 'For-Each Array', description: 'Recorre array con for-each.', difficulty: 'easy', starterCode: 'int[] nums = {1, 2, 3, 4, 5};', solution: 'for (int n : nums) {\n    System.out.println(n);\n}', hint: 'for-each: for (tipo variable : array) { }. Ejemplo: for (int n : nums)', validation: { requiredKeywords: ['for', ':'] } },
    { id: 29, lessonId: 7, title: 'Switch Día Semana', description: 'Imprime día según número.', difficulty: 'easy', starterCode: 'int dia = 3;', solution: 'switch (dia) {\n    case 1: System.out.println("Lunes"); break;\n    case 2: System.out.println("Martes"); break;\n    case 3: System.out.println("Miércoles"); break;\n    default: System.out.println("Otro día");\n}', hint: 'switch (variable) { case valor: código; break; }. No olvides break para evitar fall-through.', validation: { requiredKeywords: ['switch', 'case', 'break'] } },
    { id: 30, lessonId: 7, title: 'Switch sin Break', description: 'Fall-through intencional.', difficulty: 'medium', starterCode: '', solution: 'int mes = 2;\nswitch (mes) {\n    case 12:\n    case 1:\n    case 2:\n        System.out.println("Verano");\n        break;\n    default:\n        System.out.println("Otra estación");\n}', hint: 'Puedes omitir break para que varios cases ejecuten el mismo código (fall-through).', validation: { requiredKeywords: ['switch', 'case'] } },
    { id: 31, lessonId: 7, title: 'Switch con String', description: 'Evalúa texto.', difficulty: 'medium', starterCode: 'String color = "rojo";', solution: 'switch (color) {\n    case "rojo":\n        System.out.println("Peligro");\n        break;\n    case "verde":\n        System.out.println("Seguro");\n        break;\n    default:\n        System.out.println("Desconocido");\n}', hint: 'Desde Java 7, switch acepta String. Usa comillas dobles en los cases.', validation: { requiredKeywords: ['switch', 'case'] } },
    { id: 32, lessonId: 7, title: 'Switch Expression', description: 'Asigna valor con switch.', difficulty: 'hard', starterCode: 'int nota = 8;', solution: 'String resultado = switch (nota) {\n    case 10, 9 -> "Excelente";\n    case 8, 7 -> "Bueno";\n    default -> "Regular";\n};', hint: 'Switch expression (Java 14+): variable = switch (x) { case a -> valor; };', validation: { requiredKeywords: ['switch', '->'] } },
    { id: 33, lessonId: 8, title: 'Scanner Leer Int', description: 'Lee número del usuario.', difficulty: 'easy', starterCode: 'import java.util.Scanner;', solution: 'Scanner sc = new Scanner(System.in);\nSystem.out.print("Edad: ");\nint edad = sc.nextInt();', hint: 'Crea Scanner: Scanner sc = new Scanner(System.in); Luego usa sc.nextInt() para leer enteros.', validation: { requiredKeywords: ['Scanner', 'nextInt'] } },
    { id: 34, lessonId: 8, title: 'Scanner Leer String', description: 'Lee nombre completo.', difficulty: 'easy', starterCode: 'import java.util.Scanner;', solution: 'Scanner sc = new Scanner(System.in);\nSystem.out.print("Nombre: ");\nString nombre = sc.nextLine();', hint: 'nextLine() lee toda la línea incluyendo espacios. next() solo lee una palabra.', validation: { requiredKeywords: ['Scanner', 'nextLine'] } },
    { id: 35, lessonId: 8, title: 'Scanner Múltiples Datos', description: 'Lee nombre y edad.', difficulty: 'medium', starterCode: '', solution: 'Scanner sc = new Scanner(System.in);\nSystem.out.print("Nombre: ");\nString nombre = sc.nextLine();\nSystem.out.print("Edad: ");\nint edad = sc.nextInt();', hint: 'Puedes llamar a nextLine() y nextInt() en secuencia para leer diferentes tipos de datos.', validation: { requiredKeywords: ['Scanner', 'nextLine', 'nextInt'] } },
    { id: 36, lessonId: 8, title: 'Scanner Validar Entrada', description: 'Verifica que sea número.', difficulty: 'hard', starterCode: 'import java.util.Scanner;', solution: 'Scanner sc = new Scanner(System.in);\nif (sc.hasNextInt()) {\n    int num = sc.nextInt();\n    System.out.println("Número: " + num);\n} else {\n    System.out.println("No es número");\n}', hint: 'Usa hasNextInt() para verificar si la entrada es un entero antes de leerla con nextInt().', validation: { requiredKeywords: ['hasNextInt'] } },
    { id: 37, lessonId: 8, title: 'Scanner en Bucle', description: 'Lee hasta que sea 0.', difficulty: 'medium', starterCode: '', solution: 'Scanner sc = new Scanner(System.in);\nint num;\ndo {\n    System.out.print("Número (0 para salir): ");\n    num = sc.nextInt();\n} while (num != 0);', hint: 'Usa do-while para leer al menos una vez. La condición es num != 0 para continuar.', validation: { requiredKeywords: ['Scanner', 'do', 'while'] } },
    { id: 38, lessonId: 8, title: 'Scanner Cerrar', description: 'Cierra Scanner correctamente.', difficulty: 'easy', starterCode: 'Scanner sc = new Scanner(System.in);\nint num = sc.nextInt();', solution: 'Scanner sc = new Scanner(System.in);\nint num = sc.nextInt();\nsc.close();', hint: 'Siempre cierra Scanner con sc.close() para liberar recursos.', validation: { requiredKeywords: ['close'] } },
    { id: 39, lessonId: 8, title: 'Scanner Try-With-Resources', description: 'Scanner auto-cerrado.', difficulty: 'hard', starterCode: '', solution: 'try (Scanner sc = new Scanner(System.in)) {\n    System.out.print("Número: ");\n    int num = sc.nextInt();\n    System.out.println("Leído: " + num);\n}', hint: 'try-with-resources cierra automáticamente: try (Scanner sc = new Scanner(...)) { }', validation: { requiredKeywords: ['try', 'Scanner'] } },
    { id: 40, lessonId: 8, title: 'Scanner Leer Double', description: 'Lee decimal del usuario.', difficulty: 'easy', starterCode: 'import java.util.Scanner;', solution: 'Scanner sc = new Scanner(System.in);\nSystem.out.print("Precio: ");\ndouble precio = sc.nextDouble();', hint: 'Usa nextDouble() para leer números decimales (double).', validation: { requiredKeywords: ['Scanner', 'nextDouble'] } },

    // IDs 41-60: Módulo 3 (Arrays, Matrices, Strings, StringBuilder, Métodos)
    { id: 41, lessonId: 9, title: 'Declarar Array', description: 'Array de 5 enteros.', difficulty: 'easy', starterCode: '', solution: 'int[] nums = new int[5];', hint: 'Sintaxis: tipo[] nombre = new tipo[tamaño]; Ejemplo: int[] nums = new int[5];', validation: { requiredKeywords: ['int[]', 'new'] } },
    { id: 42, lessonId: 9, title: 'Inicializar Array', description: 'Array con valores {1,2,3}.', difficulty: 'easy', starterCode: '', solution: 'int[] nums = {1, 2, 3};', hint: 'Puedes inicializar con valores: int[] nums = {valor1, valor2, valor3};', validation: { requiredKeywords: ['int[]'] } },
    { id: 43, lessonId: 9, title: 'Acceder Elemento', description: 'Imprime primer elemento.', difficulty: 'easy', starterCode: 'int[] nums = {10, 20, 30};', solution: 'System.out.println(nums[0]);', hint: 'Los arrays empiezan en índice 0. Accede con nombreArray[índice].', validation: { requiredKeywords: ['[0]'] } },
    { id: 44, lessonId: 9, title: 'Modificar Elemento', description: 'Cambia segundo elemento a 50.', difficulty: 'easy', starterCode: 'int[] nums = {10, 20, 30};', solution: 'nums[1] = 50;', hint: 'Para modificar: nombreArray[índice] = nuevoValor; El segundo elemento está en índice 1.', validation: { requiredKeywords: ['[1]', '='] } },
    { id: 45, lessonId: 9, title: 'Longitud Array', description: 'Imprime tamaño del array.', difficulty: 'easy', starterCode: 'int[] nums = {1, 2, 3, 4, 5};', solution: 'System.out.println(nums.length);', hint: 'Usa .length (sin paréntesis) para obtener el tamaño: nums.length', validation: { requiredKeywords: ['length'] } },
    { id: 46, lessonId: 9, title: 'Recorrer Array', description: 'Imprime todos los elementos.', difficulty: 'medium', starterCode: 'int[] nums = {1, 2, 3, 4, 5};', solution: 'for (int i = 0; i < nums.length; i++) {\n    System.out.println(nums[i]);\n}', hint: 'Usa for desde 0 hasta nums.length-1. Accede a cada elemento con nums[i].', validation: { requiredKeywords: ['for', 'length'] } },
    { id: 47, lessonId: 9, title: 'Suma Array', description: 'Suma todos los elementos.', difficulty: 'medium', starterCode: 'int[] nums = {5, 10, 15, 20};', solution: 'int suma = 0;\nfor (int n : nums) {\n    suma += n;\n}\nSystem.out.println(suma);', hint: 'Inicializa suma en 0. Usa for-each para recorrer y suma += n en cada iteración.', validation: { requiredKeywords: ['for', '+='] } },
    { id: 48, lessonId: 9, title: 'Máximo en Array', description: 'Encuentra el mayor.', difficulty: 'hard', starterCode: 'int[] nums = {3, 7, 2, 9, 1};', solution: 'int max = nums[0];\nfor (int n : nums) {\n    if (n > max) max = n;\n}\nSystem.out.println(max);', hint: 'Inicializa max con el primer elemento. Recorre y actualiza max si encuentras uno mayor.', validation: { requiredKeywords: ['for', 'if'] } },
    { id: 49, lessonId: 10, title: 'Matriz 2x2', description: 'Declara matriz 2x2.', difficulty: 'medium', starterCode: '', solution: 'int[][] matriz = new int[2][2];', hint: 'Matriz: tipo[][] nombre = new tipo[filas][columnas]; Ejemplo: int[][] matriz = new int[2][2];', validation: { requiredKeywords: ['int[][]', 'new'] } },
    { id: 50, lessonId: 10, title: 'Inicializar Matriz', description: 'Matriz con valores.', difficulty: 'medium', starterCode: '', solution: 'int[][] matriz = {{1, 2}, {3, 4}};', hint: 'Inicializa con llaves anidadas: int[][] m = {{fila1}, {fila2}};', validation: { requiredKeywords: ['int[][]'] } },
    { id: 51, lessonId: 10, title: 'Acceder Matriz', description: 'Imprime elemento [1][0].', difficulty: 'medium', starterCode: 'int[][] m = {{1, 2}, {3, 4}};', solution: 'System.out.println(m[1][0]);', hint: 'Accede con matriz[fila][columna]. [1][0] es fila 1, columna 0 (valor: 3).', validation: { requiredKeywords: ['[1][0]'] } },
    { id: 52, lessonId: 10, title: 'Recorrer Matriz', description: 'Imprime todos los elementos.', difficulty: 'hard', starterCode: 'int[][] m = {{1, 2}, {3, 4}};', solution: 'for (int i = 0; i < m.length; i++) {\n    for (int j = 0; j < m[i].length; j++) {\n        System.out.print(m[i][j] + " ");\n    }\n    System.out.println();\n}', hint: 'Usa dos bucles anidados: externo para filas (m.length), interno para columnas (m[i].length).', validation: { requiredKeywords: ['for'] } },
    { id: 53, lessonId: 11, title: 'Longitud String', description: 'Imprime tamaño de texto.', difficulty: 'easy', starterCode: 'String texto = "Hola";', solution: 'System.out.println(texto.length());', hint: 'Usa .length() (con paréntesis) para Strings: texto.length()', validation: { requiredKeywords: ['length()'] } },
    { id: 54, lessonId: 11, title: 'Concatenar Strings', description: 'Une dos textos.', difficulty: 'easy', starterCode: 'String a = "Hola";\nString b = "Mundo";', solution: 'String c = a + " " + b;\nSystem.out.println(c);', hint: 'Concatena con +: String c = a + " " + b; (resultado: "Hola Mundo")', validation: { requiredKeywords: ['+'] } },
    { id: 55, lessonId: 11, title: 'Mayúsculas', description: 'Convierte a mayúsculas.', difficulty: 'easy', starterCode: 'String texto = "hola";', solution: 'String mayus = texto.toUpperCase();\nSystem.out.println(mayus);', hint: 'Usa .toUpperCase() para convertir a mayúsculas. Retorna un nuevo String.', validation: { requiredKeywords: ['toUpperCase'] } },
    { id: 56, lessonId: 11, title: 'Substring', description: 'Extrae caracteres 0 a 3.', difficulty: 'medium', starterCode: 'String texto = "Hola Mundo";', solution: 'String sub = texto.substring(0, 4);\nSystem.out.println(sub);', hint: 'substring(inicio, fin) extrae desde inicio hasta fin-1. substring(0, 4) extrae "Hola".', validation: { requiredKeywords: ['substring'] } },
    { id: 57, lessonId: 11, title: 'Comparar Strings', description: 'Verifica si son iguales.', difficulty: 'medium', starterCode: 'String a = "Hola";\nString b = "Hola";', solution: 'if (a.equals(b)) {\n    System.out.println("Iguales");\n}', hint: 'NUNCA uses == para Strings. Usa .equals(): if (a.equals(b))', validation: { requiredKeywords: ['equals'] } },
    { id: 58, lessonId: 11, title: 'StringBuilder Append', description: 'Construye texto eficientemente.', difficulty: 'medium', starterCode: '', solution: 'StringBuilder sb = new StringBuilder();\nsb.append("Hola");\nsb.append(" ");\nsb.append("Mundo");\nSystem.out.println(sb.toString());', hint: 'StringBuilder es mutable. Usa .append() para agregar y .toString() para convertir a String.', validation: { requiredKeywords: ['StringBuilder', 'append'] } },
    { id: 59, lessonId: 12, title: 'Método Sin Retorno', description: 'Crea método saludar().', difficulty: 'easy', starterCode: '', solution: 'public static void saludar() {\n    System.out.println("Hola");\n}', hint: 'Método sin retorno: public static void nombreMetodo() { código }', validation: { requiredKeywords: ['void', 'saludar'] } },
    { id: 60, lessonId: 12, title: 'Método Con Retorno', description: 'Método que suma dos números.', difficulty: 'medium', starterCode: '', solution: 'public static int sumar(int a, int b) {\n    return a + b;\n}', hint: 'Método con retorno: public static tipoRetorno nombre(parámetros) { return valor; }', validation: { requiredKeywords: ['return'] } },

    // IDs 61-120: INTERMEDIO (POO, Colecciones)
    // IDs 61-80: POO Básico
    { id: 61, lessonId: 13, title: 'Clase Simple', description: 'Crea clase Persona.', difficulty: 'easy', starterCode: '', solution: 'public class Persona {\n    String nombre;\n    int edad;\n}', hint: 'Una clase es un molde. Define atributos dentro: public class NombreClase { tipo atributo; }', validation: { requiredKeywords: ['class', 'Persona'] } },
    { id: 62, lessonId: 13, title: 'Constructor', description: 'Constructor con parámetros.', difficulty: 'medium', starterCode: 'public class Persona {\n    String nombre;\n    int edad;\n}', solution: 'public Persona(String nombre, int edad) {\n    this.nombre = nombre;\n    this.edad = edad;\n}', hint: 'Constructor: public NombreClase(parámetros) { this.atributo = parámetro; }', validation: { requiredKeywords: ['Persona', 'this'] } },
    { id: 63, lessonId: 13, title: 'Crear Objeto', description: 'Instancia de Persona.', difficulty: 'easy', starterCode: '', solution: 'Persona p = new Persona("Ana", 25);', hint: 'Crear objeto: NombreClase variable = new NombreClase(argumentos);', validation: { requiredKeywords: ['new', 'Persona'] } },
    { id: 64, lessonId: 13, title: 'Acceder Atributo', description: 'Imprime nombre del objeto.', difficulty: 'easy', starterCode: 'Persona p = new Persona("Ana", 25);', solution: 'System.out.println(p.nombre);', hint: 'Accede a atributos con objeto.atributo: p.nombre', validation: { requiredKeywords: ['.nombre'] } },
    { id: 65, lessonId: 13, title: 'Método de Instancia', description: 'Método saludar() en Persona.', difficulty: 'medium', starterCode: 'public class Persona {\n    String nombre;\n}', solution: 'public void saludar() {\n    System.out.println("Hola, soy " + nombre);\n}', hint: 'Método de instancia: public void nombreMetodo() { }. Puede usar atributos directamente.', validation: { requiredKeywords: ['void', 'saludar'] } },
    { id: 66, lessonId: 13, title: 'Llamar Método', description: 'Ejecuta método del objeto.', difficulty: 'easy', starterCode: 'Persona p = new Persona("Ana", 25);', solution: 'p.saludar();', hint: 'Llama métodos con objeto.metodo(): p.saludar();', validation: { requiredKeywords: ['.saludar'] } },
    { id: 67, lessonId: 14, title: 'Encapsulamiento Private', description: 'Atributo privado.', difficulty: 'medium', starterCode: 'public class Cuenta {\n    double saldo;\n}', solution: 'private double saldo;', hint: 'private oculta el atributo. Solo accesible dentro de la clase.', validation: { requiredKeywords: ['private'] } },
    { id: 68, lessonId: 14, title: 'Getter', description: 'Método getSaldo().', difficulty: 'medium', starterCode: 'public class Cuenta {\n    private double saldo;\n}', solution: 'public double getSaldo() {\n    return saldo;\n}', hint: 'Getter: public tipo getNombre() { return atributo; }', validation: { requiredKeywords: ['get', 'return'] } },
    { id: 69, lessonId: 14, title: 'Setter', description: 'Método setSaldo().', difficulty: 'medium', starterCode: 'public class Cuenta {\n    private double saldo;\n}', solution: 'public void setSaldo(double saldo) {\n    this.saldo = saldo;\n}', hint: 'Setter: public void setNombre(tipo param) { this.atributo = param; }', validation: { requiredKeywords: ['set', 'this'] } },
    { id: 70, lessonId: 14, title: 'Validación en Setter', description: 'Setter con validación.', difficulty: 'hard', starterCode: 'public class Persona {\n    private int edad;\n}', solution: 'public void setEdad(int edad) {\n    if (edad >= 0) {\n        this.edad = edad;\n    }\n}', hint: 'Valida antes de asignar: if (condición) { this.atributo = valor; }', validation: { requiredKeywords: ['if', 'this'] } },
    { id: 71, lessonId: 15, title: 'Herencia Extends', description: 'Estudiante hereda de Persona.', difficulty: 'medium', starterCode: 'public class Persona {\n    String nombre;\n}', solution: 'public class Estudiante extends Persona {\n    String carrera;\n}', hint: 'Herencia: class Hija extends Padre { }. Estudiante hereda atributos de Persona.', validation: { requiredKeywords: ['extends'] } },
    { id: 72, lessonId: 15, title: 'Super Constructor', description: 'Llama constructor padre.', difficulty: 'hard', starterCode: 'public class Estudiante extends Persona {\n    String carrera;\n}', solution: 'public Estudiante(String nombre, String carrera) {\n    super(nombre);\n    this.carrera = carrera;\n}', hint: 'super() llama al constructor del padre. Debe ser la primera línea.', validation: { requiredKeywords: ['super'] } },
    { id: 73, lessonId: 15, title: 'Override Método', description: 'Sobrescribe toString().', difficulty: 'medium', starterCode: 'public class Persona {\n    String nombre;\n}', solution: '@Override\npublic String toString() {\n    return "Persona: " + nombre;\n}', hint: '@Override indica que sobrescribes un método del padre o interfaz.', validation: { requiredKeywords: ['@Override', 'toString'] } },
    { id: 74, lessonId: 15, title: 'Polimorfismo', description: 'Referencia padre, objeto hijo.', difficulty: 'hard', starterCode: '', solution: 'Persona p = new Estudiante("Ana", "Ingeniería");', hint: 'Polimorfismo: TipoPadre variable = new TipoHijo(); Permite flexibilidad.', validation: { requiredKeywords: ['Persona', 'Estudiante'] } },
    { id: 75, lessonId: 16, title: 'Clase Abstracta', description: 'Define clase abstracta.', difficulty: 'medium', starterCode: '', solution: 'public abstract class Animal {\n    public abstract void hacerSonido();\n}', hint: 'abstract class no se puede instanciar. Métodos abstract no tienen cuerpo.', validation: { requiredKeywords: ['abstract'] } },
    { id: 76, lessonId: 16, title: 'Implementar Abstracto', description: 'Perro extiende Animal.', difficulty: 'hard', starterCode: 'public abstract class Animal {\n    public abstract void hacerSonido();\n}', solution: 'public class Perro extends Animal {\n    @Override\n    public void hacerSonido() {\n        System.out.println("Guau");\n    }\n}', hint: 'Clases concretas deben implementar todos los métodos abstractos con @Override.', validation: { requiredKeywords: ['extends', '@Override'] } },
    { id: 77, lessonId: 17, title: 'Interfaz', description: 'Define interfaz Volador.', difficulty: 'medium', starterCode: '', solution: 'public interface Volador {\n    void volar();\n}', hint: 'interface define un contrato. Métodos son públicos y abstractos por defecto.', validation: { requiredKeywords: ['interface'] } },
    { id: 78, lessonId: 17, title: 'Implementar Interfaz', description: 'Ave implementa Volador.', difficulty: 'medium', starterCode: 'public interface Volador {\n    void volar();\n}', solution: 'public class Ave implements Volador {\n    @Override\n    public void volar() {\n        System.out.println("Volando");\n    }\n}', hint: 'implements indica que la clase cumple el contrato de la interfaz.', validation: { requiredKeywords: ['implements', '@Override'] } },
    { id: 79, lessonId: 17, title: 'Múltiples Interfaces', description: 'Clase implementa 2 interfaces.', difficulty: 'hard', starterCode: '', solution: 'public class Pato implements Volador, Nadador {\n    public void volar() { }\n    public void nadar() { }\n}', hint: 'Una clase puede implementar múltiples interfaces: implements I1, I2', validation: { requiredKeywords: ['implements'] } },
    { id: 80, lessonId: 17, title: 'Interfaz con Default', description: 'Método default en interfaz.', difficulty: 'hard', starterCode: 'public interface Saludable {\n    void saludar();\n}', solution: 'default void despedir() {\n    System.out.println("Adiós");\n}', hint: 'Métodos default (Java 8+) tienen implementación en la interfaz.', validation: { requiredKeywords: ['default'] } },

    // IDs 81-100: POO Avanzado
    { id: 81, lessonId: 18, title: 'Atributo Static', description: 'Variable compartida por todos.', difficulty: 'medium', starterCode: 'public class Contador {\n    int valor;\n}', solution: 'static int total = 0;', hint: 'static pertenece a la clase, no a instancias. Se comparte entre todos los objetos.', validation: { requiredKeywords: ['static'] } },
    { id: 82, lessonId: 18, title: 'Método Static', description: 'Método de clase.', difficulty: 'medium', starterCode: 'public class Utilidades {\n}', solution: 'public static int sumar(int a, int b) {\n    return a + b;\n}', hint: 'Métodos static se llaman con NombreClase.metodo(), no necesitan instancia.', validation: { requiredKeywords: ['static'] } },
    { id: 83, lessonId: 18, title: 'Constante Static Final', description: 'Constante de clase.', difficulty: 'easy', starterCode: '', solution: 'public static final double PI = 3.14159;', hint: 'static final define constantes de clase. Por convención en MAYÚSCULAS.', validation: { requiredKeywords: ['static', 'final'] } },
    { id: 84, lessonId: 18, title: 'Bloque Static', description: 'Inicialización estática.', difficulty: 'hard', starterCode: 'public class Config {\n    static String url;\n}', solution: 'static {\n    url = "http://localhost";\n}', hint: 'Bloque static { } se ejecuta una vez al cargar la clase.', validation: { requiredKeywords: ['static'] } },
    { id: 85, lessonId: 19, title: 'Clase Interna', description: 'Inner class.', difficulty: 'medium', starterCode: 'public class Externa {\n}', solution: 'class Interna {\n    void metodo() { }\n}', hint: 'Clase interna se define dentro de otra clase. Tiene acceso a miembros de la externa.', validation: { requiredKeywords: ['class'] } },
    { id: 86, lessonId: 19, title: 'Clase Anónima', description: 'Implementa interfaz inline.', difficulty: 'hard', starterCode: 'Runnable r = ', solution: 'new Runnable() {\n    @Override\n    public void run() {\n        System.out.println("Hola");\n    }\n};', hint: 'Clase anónima: new Interfaz() { métodos }; Útil para implementaciones únicas.', validation: { requiredKeywords: ['new', '@Override'] } },
    { id: 87, lessonId: 19, title: 'Enum Simple', description: 'Define enum Dia.', difficulty: 'easy', starterCode: '', solution: 'public enum Dia {\n    LUNES, MARTES, MIERCOLES\n}', hint: 'enum define un conjunto fijo de constantes: enum Nombre { VALOR1, VALOR2 }', validation: { requiredKeywords: ['enum'] } },
    { id: 88, lessonId: 19, title: 'Enum con Constructor', description: 'Enum con atributos.', difficulty: 'hard', starterCode: '', solution: 'public enum Talla {\n    S(1), M(2), L(3);\n    private int numero;\n    Talla(int numero) {\n        this.numero = numero;\n    }\n}', hint: 'Enums pueden tener constructores y atributos. Constructor es privado.', validation: { requiredKeywords: ['enum', 'private'] } },
    { id: 89, lessonId: 20, title: 'Equals Override', description: 'Sobrescribe equals().', difficulty: 'hard', starterCode: 'public class Persona {\n    String nombre;\n}', solution: '@Override\npublic boolean equals(Object obj) {\n    if (obj instanceof Persona) {\n        return nombre.equals(((Persona) obj).nombre);\n    }\n    return false;\n}', hint: 'equals() compara contenido. Usa instanceof y casting.', validation: { requiredKeywords: ['@Override', 'equals', 'instanceof'] } },
    { id: 90, lessonId: 20, title: 'HashCode Override', description: 'Sobrescribe hashCode().', difficulty: 'hard', starterCode: 'public class Persona {\n    String nombre;\n}', solution: '@Override\npublic int hashCode() {\n    return nombre.hashCode();\n}', hint: 'Si sobrescribes equals(), también debes sobrescribir hashCode().', validation: { requiredKeywords: ['@Override', 'hashCode'] } },
    { id: 91, lessonId: 20, title: 'CompareTo', description: 'Implementa Comparable.', difficulty: 'hard', starterCode: 'public class Persona implements Comparable<Persona> {\n    int edad;\n}', solution: '@Override\npublic int compareTo(Persona otra) {\n    return Integer.compare(this.edad, otra.edad);\n}', hint: 'compareTo() retorna negativo, 0, o positivo según el orden.', validation: { requiredKeywords: ['@Override', 'compareTo'] } },
    { id: 92, lessonId: 21, title: 'Genérico Simple', description: 'Clase genérica Caja<T>.', difficulty: 'medium', starterCode: '', solution: 'public class Caja<T> {\n    private T contenido;\n    public void guardar(T item) {\n        contenido = item;\n    }\n}', hint: 'Genéricos usan <T> como tipo parámetro. T se reemplaza al usar la clase.', validation: { requiredKeywords: ['<T>'] } },
    { id: 93, lessonId: 21, title: 'Método Genérico', description: 'Método con tipo genérico.', difficulty: 'medium', starterCode: '', solution: 'public static <T> void imprimir(T elemento) {\n    System.out.println(elemento);\n}', hint: 'Método genérico: <T> antes del tipo de retorno. Ejemplo: <T> void metodo(T param)', validation: { requiredKeywords: ['<T>'] } },
    { id: 94, lessonId: 21, title: 'Bounded Type', description: 'Genérico con límite.', difficulty: 'hard', starterCode: '', solution: 'public class Comparador<T extends Comparable<T>> {\n    public T mayor(T a, T b) {\n        return a.compareTo(b) > 0 ? a : b;\n    }\n}', hint: '<T extends Tipo> limita T a subtipos de Tipo.', validation: { requiredKeywords: ['<T extends'] } },
    { id: 95, lessonId: 21, title: 'Wildcard ?', description: 'Comodín en genéricos.', difficulty: 'hard', starterCode: '', solution: 'public void imprimir(List<?> lista) {\n    for (Object obj : lista) {\n        System.out.println(obj);\n    }\n}', hint: '? (wildcard) acepta cualquier tipo. List<?> acepta List de cualquier cosa.', validation: { requiredKeywords: ['?'] } },
    { id: 96, lessonId: 22, title: 'Record Simple', description: 'Define record Punto.', difficulty: 'medium', starterCode: '', solution: 'public record Punto(int x, int y) { }', hint: 'record (Java 14+) es una clase inmutable con constructor, getters, equals, hashCode y toString automáticos.', validation: { requiredKeywords: ['record'] } },
    { id: 97, lessonId: 22, title: 'Sealed Class', description: 'Clase sellada.', difficulty: 'hard', starterCode: '', solution: 'public sealed class Forma permits Circulo, Cuadrado { }', hint: 'sealed (Java 17+) restringe qué clases pueden heredar. Usa permits.', validation: { requiredKeywords: ['sealed', 'permits'] } },
    { id: 98, lessonId: 22, title: 'Pattern Matching', description: 'instanceof con pattern.', difficulty: 'medium', starterCode: 'Object obj = "Hola";', solution: 'if (obj instanceof String s) {\n    System.out.println(s.toUpperCase());\n}', hint: 'Pattern matching (Java 16+): instanceof Tipo variable declara la variable automáticamente.', validation: { requiredKeywords: ['instanceof'] } },
    { id: 99, lessonId: 22, title: 'Text Blocks', description: 'String multilínea.', difficulty: 'easy', starterCode: '', solution: 'String json = """\n    {\n        "nombre": "Ana"\n    }\n    """;', hint: 'Text blocks (Java 15+): """ texto multilínea """ preserva formato.', validation: { requiredKeywords: ['"""'] } },
    { id: 100, lessonId: 22, title: 'Switch Expression Yield', description: 'Switch con yield.', difficulty: 'hard', starterCode: 'int dia = 3;', solution: 'String tipo = switch (dia) {\n    case 1, 7 -> "Fin de semana";\n    case 2, 3, 4, 5, 6 -> {\n        System.out.println("Día laboral");\n        yield "Laboral";\n    }\n    default -> "Desconocido";\n};', hint: 'yield retorna un valor desde un bloque en switch expression.', validation: { requiredKeywords: ['switch', 'yield'] } },

    // IDs 101-120: Colecciones
    { id: 101, lessonId: 23, title: 'ArrayList Crear', description: 'Crea ArrayList de Strings.', difficulty: 'easy', starterCode: 'import java.util.ArrayList;', solution: 'ArrayList<String> lista = new ArrayList<>();', hint: 'ArrayList<Tipo> nombre = new ArrayList<>(); Es una lista dinámica.', validation: { requiredKeywords: ['ArrayList', 'new'] } },
    { id: 102, lessonId: 23, title: 'ArrayList Add', description: 'Agrega elementos.', difficulty: 'easy', starterCode: 'ArrayList<String> lista = new ArrayList<>();', solution: 'lista.add("Hola");\nlista.add("Mundo");', hint: 'Usa .add(elemento) para agregar al final de la lista.', validation: { requiredKeywords: ['add'] } },
    { id: 103, lessonId: 23, title: 'ArrayList Get', description: 'Obtiene elemento por índice.', difficulty: 'easy', starterCode: 'ArrayList<String> lista = new ArrayList<>();\nlista.add("Hola");', solution: 'String primero = lista.get(0);', hint: 'Usa .get(índice) para obtener un elemento. Índices empiezan en 0.', validation: { requiredKeywords: ['get'] } },
    { id: 104, lessonId: 23, title: 'ArrayList Remove', description: 'Elimina elemento.', difficulty: 'medium', starterCode: 'ArrayList<String> lista = new ArrayList<>();\nlista.add("A");\nlista.add("B");', solution: 'lista.remove(0);', hint: 'remove(índice) elimina por posición. remove(objeto) elimina por valor.', validation: { requiredKeywords: ['remove'] } },
    { id: 105, lessonId: 23, title: 'ArrayList Size', description: 'Tamaño de la lista.', difficulty: 'easy', starterCode: 'ArrayList<Integer> nums = new ArrayList<>();', solution: 'int tamaño = nums.size();', hint: 'Usa .size() para obtener la cantidad de elementos.', validation: { requiredKeywords: ['size'] } },
    { id: 106, lessonId: 23, title: 'ArrayList Iterar', description: 'Recorre con for-each.', difficulty: 'medium', starterCode: 'ArrayList<String> lista = new ArrayList<>();', solution: 'for (String item : lista) {\n    System.out.println(item);\n}', hint: 'for (Tipo variable : lista) { } recorre todos los elementos.', validation: { requiredKeywords: ['for', ':'] } },
    { id: 107, lessonId: 24, title: 'HashSet Crear', description: 'Set sin duplicados.', difficulty: 'easy', starterCode: 'import java.util.HashSet;', solution: 'HashSet<String> set = new HashSet<>();', hint: 'HashSet no permite duplicados y no garantiza orden.', validation: { requiredKeywords: ['HashSet'] } },
    { id: 108, lessonId: 24, title: 'HashSet Add Duplicado', description: 'Intenta agregar duplicado.', difficulty: 'medium', starterCode: 'HashSet<String> set = new HashSet<>();', solution: 'set.add("Hola");\nset.add("Hola");\nSystem.out.println(set.size());', hint: 'add() retorna false si el elemento ya existe. size() será 1.', validation: { requiredKeywords: ['add', 'size'] } },
    { id: 109, lessonId: 24, title: 'HashSet Contains', description: 'Verifica si existe.', difficulty: 'easy', starterCode: 'HashSet<String> set = new HashSet<>();\nset.add("Java");', solution: 'boolean existe = set.contains("Java");', hint: 'contains(elemento) retorna true si el elemento está en el set.', validation: { requiredKeywords: ['contains'] } },
    { id: 110, lessonId: 25, title: 'HashMap Crear', description: 'Mapa clave-valor.', difficulty: 'easy', starterCode: 'import java.util.HashMap;', solution: 'HashMap<String, Integer> mapa = new HashMap<>();', hint: 'HashMap<TipoClave, TipoValor> almacena pares clave-valor.', validation: { requiredKeywords: ['HashMap'] } },
    { id: 111, lessonId: 25, title: 'HashMap Put', description: 'Agrega par clave-valor.', difficulty: 'easy', starterCode: 'HashMap<String, Integer> edades = new HashMap<>();', solution: 'edades.put("Ana", 25);\nedades.put("Luis", 30);', hint: 'put(clave, valor) agrega o actualiza un par.', validation: { requiredKeywords: ['put'] } },
    { id: 112, lessonId: 25, title: 'HashMap Get', description: 'Obtiene valor por clave.', difficulty: 'easy', starterCode: 'HashMap<String, Integer> edades = new HashMap<>();\nedades.put("Ana", 25);', solution: 'int edad = edades.get("Ana");', hint: 'get(clave) retorna el valor asociado. Retorna null si no existe.', validation: { requiredKeywords: ['get'] } },
    { id: 113, lessonId: 25, title: 'HashMap ContainsKey', description: 'Verifica si existe clave.', difficulty: 'medium', starterCode: 'HashMap<String, Integer> mapa = new HashMap<>();', solution: 'if (mapa.containsKey("Ana")) {\n    System.out.println("Existe");\n}', hint: 'containsKey(clave) verifica si la clave existe antes de usar get().', validation: { requiredKeywords: ['containsKey'] } },
    { id: 114, lessonId: 25, title: 'HashMap Iterar', description: 'Recorre con entrySet.', difficulty: 'hard', starterCode: 'HashMap<String, Integer> edades = new HashMap<>();', solution: 'for (Map.Entry<String, Integer> entry : edades.entrySet()) {\n    System.out.println(entry.getKey() + ": " + entry.getValue());\n}', hint: 'entrySet() retorna pares. Usa getKey() y getValue().', validation: { requiredKeywords: ['entrySet', 'getKey', 'getValue'] } },
    { id: 115, lessonId: 26, title: 'LinkedList Crear', description: 'Lista enlazada.', difficulty: 'easy', starterCode: 'import java.util.LinkedList;', solution: 'LinkedList<String> lista = new LinkedList<>();', hint: 'LinkedList es eficiente para insertar/eliminar en medio.', validation: { requiredKeywords: ['LinkedList'] } },
    { id: 116, lessonId: 26, title: 'LinkedList AddFirst', description: 'Agrega al inicio.', difficulty: 'medium', starterCode: 'LinkedList<String> lista = new LinkedList<>();', solution: 'lista.addFirst("Primero");\nlista.addLast("Último");', hint: 'addFirst() y addLast() agregan en extremos específicos.', validation: { requiredKeywords: ['addFirst'] } },
    { id: 117, lessonId: 26, title: 'TreeSet Ordenado', description: 'Set ordenado.', difficulty: 'medium', starterCode: 'import java.util.TreeSet;', solution: 'TreeSet<Integer> set = new TreeSet<>();\nset.add(5);\nset.add(1);\nset.add(3);', hint: 'TreeSet mantiene elementos ordenados automáticamente.', validation: { requiredKeywords: ['TreeSet'] } },
    { id: 118, lessonId: 27, title: 'Collections Sort', description: 'Ordena ArrayList.', difficulty: 'medium', starterCode: 'import java.util.*;\nArrayList<Integer> nums = new ArrayList<>();', solution: 'Collections.sort(nums);', hint: 'Collections.sort(lista) ordena in-place.', validation: { requiredKeywords: ['Collections.sort'] } },
    { id: 119, lessonId: 27, title: 'Collections Reverse', description: 'Invierte lista.', difficulty: 'easy', starterCode: 'import java.util.*;\nArrayList<String> lista = new ArrayList<>();', solution: 'Collections.reverse(lista);', hint: 'Collections.reverse(lista) invierte el orden.', validation: { requiredKeywords: ['Collections.reverse'] } },
    { id: 120, lessonId: 27, title: 'Collections Max', description: 'Encuentra máximo.', difficulty: 'medium', starterCode: 'import java.util.*;\nArrayList<Integer> nums = new ArrayList<>();', solution: 'int max = Collections.max(nums);', hint: 'Collections.max(colección) retorna el elemento mayor.', validation: { requiredKeywords: ['Collections.max'] } },

    // IDs 121-168: AVANZADO (Excepciones, Functional, Stream, I/O)
    // IDs 121-140: Excepciones y manejo de errores
    { id: 121, lessonId: 28, title: 'Try-Catch Básico', description: 'Captura excepción.', difficulty: 'easy', starterCode: 'int x = Integer.parseInt("abc");', solution: 'try {\n    int x = Integer.parseInt("abc");\n} catch (NumberFormatException e) {\n    System.out.println("Error de formato");\n}', hint: 'try { código } catch (TipoExcepción e) { manejo }', validation: { requiredKeywords: ['try', 'catch'] } },
    { id: 122, lessonId: 28, title: 'Múltiples Catch', description: 'Varios tipos de excepciones.', difficulty: 'medium', starterCode: '', solution: 'try {\n    // código\n} catch (NullPointerException e) {\n    System.out.println("Null");\n} catch (ArrayIndexOutOfBoundsException e) {\n    System.out.println("Índice");\n}', hint: 'Puedes tener múltiples bloques catch para diferentes excepciones.', validation: { requiredKeywords: ['try', 'catch'] } },
    { id: 123, lessonId: 28, title: 'Finally', description: 'Bloque finally.', difficulty: 'medium', starterCode: '', solution: 'try {\n    // código\n} catch (Exception e) {\n    // manejo\n} finally {\n    System.out.println("Siempre se ejecuta");\n}', hint: 'finally se ejecuta siempre, haya o no excepción.', validation: { requiredKeywords: ['finally'] } },
    { id: 124, lessonId: 28, title: 'Throw Exception', description: 'Lanza excepción.', difficulty: 'medium', starterCode: 'public void validar(int edad) {', solution: 'if (edad < 0) {\n    throw new IllegalArgumentException("Edad negativa");\n}', hint: 'throw new TipoExcepción("mensaje") lanza una excepción.', validation: { requiredKeywords: ['throw', 'new'] } },
    { id: 125, lessonId: 28, title: 'Throws en Firma', description: 'Declara excepción.', difficulty: 'medium', starterCode: '', solution: 'public void leerArchivo() throws IOException {\n    // código que puede lanzar IOException\n}', hint: 'throws en la firma indica que el método puede lanzar esa excepción.', validation: { requiredKeywords: ['throws'] } },
    { id: 126, lessonId: 29, title: 'Excepción Personalizada', description: 'Crea excepción propia.', difficulty: 'hard', starterCode: '', solution: 'public class MiExcepcion extends Exception {\n    public MiExcepcion(String mensaje) {\n        super(mensaje);\n    }\n}', hint: 'Extiende Exception para crear excepciones personalizadas.', validation: { requiredKeywords: ['extends', 'Exception'] } },
    { id: 127, lessonId: 29, title: 'RuntimeException', description: 'Excepción no verificada.', difficulty: 'medium', starterCode: '', solution: 'public class ErrorNegocio extends RuntimeException {\n    public ErrorNegocio(String msg) {\n        super(msg);\n    }\n}', hint: 'RuntimeException no necesita ser declarada con throws.', validation: { requiredKeywords: ['RuntimeException'] } },
    { id: 128, lessonId: 29, title: 'Try-With-Resources', description: 'Cierre automático.', difficulty: 'hard', starterCode: 'import java.io.*;', solution: 'try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {\n    String linea = br.readLine();\n} catch (IOException e) {\n    e.printStackTrace();\n}', hint: 'try (recurso) { } cierra automáticamente recursos AutoCloseable.', validation: { requiredKeywords: ['try'] } },
    { id: 129, lessonId: 29, title: 'Multi-Catch', description: 'Captura múltiples en uno.', difficulty: 'medium', starterCode: '', solution: 'try {\n    // código\n} catch (IOException | SQLException e) {\n    System.out.println("Error de I/O o BD");\n}', hint: 'catch (Tipo1 | Tipo2 e) captura múltiples excepciones en un solo bloque.', validation: { requiredKeywords: ['|'] } },
    { id: 130, lessonId: 29, title: 'GetMessage', description: 'Obtiene mensaje de error.', difficulty: 'easy', starterCode: 'catch (Exception e) {', solution: 'String msg = e.getMessage();\nSystem.out.println(msg);', hint: 'e.getMessage() retorna el mensaje de la excepción.', validation: { requiredKeywords: ['getMessage'] } },
    { id: 131, lessonId: 30, title: 'PrintStackTrace', description: 'Imprime traza completa.', difficulty: 'easy', starterCode: 'catch (Exception e) {', solution: 'e.printStackTrace();', hint: 'printStackTrace() muestra la traza completa del error en consola.', validation: { requiredKeywords: ['printStackTrace'] } },
    { id: 132, lessonId: 30, title: 'Causa de Excepción', description: 'Excepción con causa.', difficulty: 'hard', starterCode: '', solution: 'try {\n    // código\n} catch (IOException e) {\n    throw new RuntimeException("Error procesando", e);\n}', hint: 'Pasa la excepción original como segundo parámetro para preservar la causa.', validation: { requiredKeywords: ['throw', 'new'] } },
    { id: 133, lessonId: 30, title: 'Assert', description: 'Usa aserciones.', difficulty: 'medium', starterCode: 'int edad = -5;', solution: 'assert edad >= 0 : "Edad no puede ser negativa";', hint: 'assert condición : mensaje; Lanza AssertionError si la condición es falsa.', validation: { requiredKeywords: ['assert'] } },
    { id: 134, lessonId: 30, title: 'NullPointerException', description: 'Maneja null.', difficulty: 'easy', starterCode: 'String texto = null;', solution: 'try {\n    int len = texto.length();\n} catch (NullPointerException e) {\n    System.out.println("Texto es null");\n}', hint: 'NullPointerException ocurre al usar métodos en objetos null.', validation: { requiredKeywords: ['NullPointerException'] } },
    { id: 135, lessonId: 31, title: 'Optional Empty', description: 'Crea Optional vacío.', difficulty: 'easy', starterCode: 'import java.util.Optional;', solution: 'Optional<String> opt = Optional.empty();', hint: 'Optional.empty() crea un Optional sin valor.', validation: { requiredKeywords: ['Optional.empty'] } },
    { id: 136, lessonId: 31, title: 'Optional Of', description: 'Optional con valor.', difficulty: 'easy', starterCode: 'import java.util.Optional;', solution: 'Optional<String> opt = Optional.of("Hola");', hint: 'Optional.of(valor) crea un Optional con valor (lanza excepción si es null).', validation: { requiredKeywords: ['Optional.of'] } },
    { id: 137, lessonId: 31, title: 'Optional OfNullable', description: 'Optional que acepta null.', difficulty: 'medium', starterCode: 'String texto = null;', solution: 'Optional<String> opt = Optional.ofNullable(texto);', hint: 'ofNullable acepta null y crea Optional.empty() si es null.', validation: { requiredKeywords: ['ofNullable'] } },
    { id: 138, lessonId: 31, title: 'Optional IsPresent', description: 'Verifica si tiene valor.', difficulty: 'easy', starterCode: 'Optional<String> opt = Optional.of("Hola");', solution: 'if (opt.isPresent()) {\n    System.out.println(opt.get());\n}', hint: 'isPresent() retorna true si hay valor. get() obtiene el valor.', validation: { requiredKeywords: ['isPresent', 'get'] } },
    { id: 139, lessonId: 31, title: 'Optional OrElse', description: 'Valor por defecto.', difficulty: 'medium', starterCode: 'Optional<String> opt = Optional.empty();', solution: 'String valor = opt.orElse("Defecto");', hint: 'orElse(valorDefecto) retorna el valor o el defecto si está vacío.', validation: { requiredKeywords: ['orElse'] } },
    { id: 140, lessonId: 31, title: 'Optional IfPresent', description: 'Ejecuta si hay valor.', difficulty: 'medium', starterCode: 'Optional<String> opt = Optional.of("Hola");', solution: 'opt.ifPresent(valor -> System.out.println(valor));', hint: 'ifPresent(lambda) ejecuta la lambda solo si hay valor.', validation: { requiredKeywords: ['ifPresent', '->'] } },

    // IDs 141-156: Programación Funcional y Lambdas
    { id: 141, lessonId: 32, title: 'Lambda Simple', description: 'Expresión lambda básica.', difficulty: 'easy', starterCode: 'Runnable r = ', solution: '() -> System.out.println("Hola");', hint: 'Lambda: (parámetros) -> expresión. Sin parámetros: () -> código', validation: { requiredKeywords: ['->'] } },
    { id: 142, lessonId: 32, title: 'Lambda Con Parámetro', description: 'Lambda con un parámetro.', difficulty: 'easy', starterCode: 'Consumer<String> c = ', solution: 's -> System.out.println(s);', hint: 'Un parámetro: parámetro -> código (sin paréntesis)', validation: { requiredKeywords: ['->'] } },
    { id: 143, lessonId: 32, title: 'Lambda Múltiples Parámetros', description: 'Lambda con dos parámetros.', difficulty: 'medium', starterCode: 'BiFunction<Integer, Integer, Integer> suma = ', solution: '(a, b) -> a + b;', hint: 'Múltiples parámetros: (p1, p2) -> expresión', validation: { requiredKeywords: ['->'] } },
    { id: 144, lessonId: 32, title: 'Lambda Bloque', description: 'Lambda con varias líneas.', difficulty: 'medium', starterCode: 'Consumer<String> c = ', solution: 's -> {\n    String mayus = s.toUpperCase();\n    System.out.println(mayus);\n};', hint: 'Bloque: parámetro -> { múltiples líneas }', validation: { requiredKeywords: ['->'] } },
    { id: 145, lessonId: 33, title: 'Predicate Test', description: 'Predicate para filtrar.', difficulty: 'medium', starterCode: 'import java.util.function.Predicate;', solution: 'Predicate<Integer> esPar = n -> n % 2 == 0;\nboolean resultado = esPar.test(4);', hint: 'Predicate<T> tiene método test(T) que retorna boolean.', validation: { requiredKeywords: ['Predicate', 'test'] } },
    { id: 146, lessonId: 33, title: 'Function Apply', description: 'Function para transformar.', difficulty: 'medium', starterCode: 'import java.util.function.Function;', solution: 'Function<String, Integer> longitud = s -> s.length();\nint len = longitud.apply("Hola");', hint: 'Function<T, R> transforma T en R con apply(T).', validation: { requiredKeywords: ['Function', 'apply'] } },
    { id: 147, lessonId: 33, title: 'Consumer Accept', description: 'Consumer para consumir.', difficulty: 'easy', starterCode: 'import java.util.function.Consumer;', solution: 'Consumer<String> imprimir = s -> System.out.println(s);\nimprimir.accept("Hola");', hint: 'Consumer<T> acepta T y no retorna nada. Usa accept(T).', validation: { requiredKeywords: ['Consumer', 'accept'] } },
    { id: 148, lessonId: 33, title: 'Supplier Get', description: 'Supplier para proveer.', difficulty: 'medium', starterCode: 'import java.util.function.Supplier;', solution: 'Supplier<Double> random = () -> Math.random();\ndouble num = random.get();', hint: 'Supplier<T> no recibe parámetros y retorna T con get().', validation: { requiredKeywords: ['Supplier', 'get'] } },
    { id: 149, lessonId: 34, title: 'Method Reference Static', description: 'Referencia a método estático.', difficulty: 'medium', starterCode: 'Function<String, Integer> parser = ', solution: 'Integer::parseInt;', hint: 'Clase::métodoEstático es equivalente a s -> Clase.método(s)', validation: { requiredKeywords: ['::'] } },
    { id: 150, lessonId: 34, title: 'Method Reference Instance', description: 'Referencia a método de instancia.', difficulty: 'medium', starterCode: 'Consumer<String> print = ', solution: 'System.out::println;', hint: 'objeto::método es equivalente a x -> objeto.método(x)', validation: { requiredKeywords: ['::'] } },
    { id: 151, lessonId: 34, title: 'Method Reference Constructor', description: 'Referencia a constructor.', difficulty: 'hard', starterCode: 'Supplier<ArrayList<String>> listFactory = ', solution: 'ArrayList::new;', hint: 'Clase::new es equivalente a () -> new Clase()', validation: { requiredKeywords: ['::new'] } },
    { id: 152, lessonId: 35, title: 'Stream Filter', description: 'Filtra elementos.', difficulty: 'medium', starterCode: 'List<Integer> nums = Arrays.asList(1,2,3,4,5);', solution: 'List<Integer> pares = nums.stream()\n    .filter(n -> n % 2 == 0)\n    .collect(Collectors.toList());', hint: 'filter(predicate) mantiene solo elementos que cumplen la condición.', validation: { requiredKeywords: ['filter', 'collect'] } },
    { id: 153, lessonId: 35, title: 'Stream Map', description: 'Transforma elementos.', difficulty: 'medium', starterCode: 'List<String> nombres = Arrays.asList("Ana", "Luis");', solution: 'List<Integer> longitudes = nombres.stream()\n    .map(s -> s.length())\n    .collect(Collectors.toList());', hint: 'map(function) transforma cada elemento aplicando la función.', validation: { requiredKeywords: ['map', 'collect'] } },
    { id: 154, lessonId: 35, title: 'Stream ForEach', description: 'Itera sobre elementos.', difficulty: 'easy', starterCode: 'List<String> lista = Arrays.asList("A", "B", "C");', solution: 'lista.stream().forEach(s -> System.out.println(s));', hint: 'forEach(consumer) ejecuta una acción para cada elemento.', validation: { requiredKeywords: ['forEach'] } },
    { id: 155, lessonId: 35, title: 'Stream Count', description: 'Cuenta elementos.', difficulty: 'easy', starterCode: 'List<Integer> nums = Arrays.asList(1,2,3,4,5);', solution: 'long cantidad = nums.stream().count();', hint: 'count() retorna el número de elementos en el stream.', validation: { requiredKeywords: ['count'] } },
    { id: 156, lessonId: 35, title: 'Stream Reduce', description: 'Reduce a un valor.', difficulty: 'hard', starterCode: 'List<Integer> nums = Arrays.asList(1,2,3,4,5);', solution: 'int suma = nums.stream()\n    .reduce(0, (a, b) -> a + b);', hint: 'reduce(inicial, acumulador) combina elementos. Ejemplo: suma.', validation: { requiredKeywords: ['reduce'] } },

    // IDs 157-168: Streams avanzados e I/O
    { id: 157, lessonId: 36, title: 'Stream Sorted', description: 'Ordena elementos.', difficulty: 'easy', starterCode: 'List<Integer> nums = Arrays.asList(5,2,8,1);', solution: 'List<Integer> ordenados = nums.stream()\n    .sorted()\n    .collect(Collectors.toList());', hint: 'sorted() ordena los elementos en orden natural.', validation: { requiredKeywords: ['sorted'] } },
    { id: 158, lessonId: 36, title: 'Stream Distinct', description: 'Elimina duplicados.', difficulty: 'easy', starterCode: 'List<Integer> nums = Arrays.asList(1,2,2,3,3,3);', solution: 'List<Integer> unicos = nums.stream()\n    .distinct()\n    .collect(Collectors.toList());', hint: 'distinct() elimina elementos duplicados.', validation: { requiredKeywords: ['distinct'] } },
    { id: 159, lessonId: 36, title: 'Stream Limit', description: 'Limita cantidad.', difficulty: 'easy', starterCode: 'List<Integer> nums = Arrays.asList(1,2,3,4,5);', solution: 'List<Integer> primeros = nums.stream()\n    .limit(3)\n    .collect(Collectors.toList());', hint: 'limit(n) toma solo los primeros n elementos.', validation: { requiredKeywords: ['limit'] } },
    { id: 160, lessonId: 36, title: 'Stream AnyMatch', description: 'Verifica si alguno cumple.', difficulty: 'medium', starterCode: 'List<Integer> nums = Arrays.asList(1,2,3,4,5);', solution: 'boolean hayPar = nums.stream()\n    .anyMatch(n -> n % 2 == 0);', hint: 'anyMatch(predicate) retorna true si al menos uno cumple.', validation: { requiredKeywords: ['anyMatch'] } },
    { id: 161, lessonId: 36, title: 'Stream AllMatch', description: 'Verifica si todos cumplen.', difficulty: 'medium', starterCode: 'List<Integer> nums = Arrays.asList(2,4,6,8);', solution: 'boolean todosPares = nums.stream()\n    .allMatch(n -> n % 2 == 0);', hint: 'allMatch(predicate) retorna true si todos cumplen.', validation: { requiredKeywords: ['allMatch'] } },
    { id: 162, lessonId: 37, title: 'File Write', description: 'Escribe archivo.', difficulty: 'medium', starterCode: 'import java.nio.file.*;', solution: 'String contenido = "Hola Mundo";\nFiles.writeString(Path.of("archivo.txt"), contenido);', hint: 'Files.writeString(path, contenido) escribe texto a un archivo.', validation: { requiredKeywords: ['Files.writeString'] } },
    { id: 163, lessonId: 37, title: 'File Read', description: 'Lee archivo.', difficulty: 'medium', starterCode: 'import java.nio.file.*;', solution: 'String contenido = Files.readString(Path.of("archivo.txt"));', hint: 'Files.readString(path) lee todo el contenido como String.', validation: { requiredKeywords: ['Files.readString'] } },
    { id: 164, lessonId: 37, title: 'File Exists', description: 'Verifica si existe.', difficulty: 'easy', starterCode: 'import java.nio.file.*;', solution: 'boolean existe = Files.exists(Path.of("archivo.txt"));', hint: 'Files.exists(path) retorna true si el archivo existe.', validation: { requiredKeywords: ['Files.exists'] } },
    { id: 165, lessonId: 37, title: 'File Delete', description: 'Elimina archivo.', difficulty: 'easy', starterCode: 'import java.nio.file.*;', solution: 'Files.deleteIfExists(Path.of("archivo.txt"));', hint: 'Files.deleteIfExists(path) elimina el archivo si existe.', validation: { requiredKeywords: ['deleteIfExists'] } },
    { id: 166, lessonId: 38, title: 'BufferedReader', description: 'Lee línea por línea.', difficulty: 'hard', starterCode: 'import java.io.*;', solution: 'try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {\n    String linea;\n    while ((linea = br.readLine()) != null) {\n        System.out.println(linea);\n    }\n}', hint: 'BufferedReader.readLine() lee una línea. Retorna null al final.', validation: { requiredKeywords: ['BufferedReader', 'readLine'] } },
    { id: 167, lessonId: 38, title: 'BufferedWriter', description: 'Escribe con buffer.', difficulty: 'medium', starterCode: 'import java.io.*;', solution: 'try (BufferedWriter bw = new BufferedWriter(new FileWriter("file.txt"))) {\n    bw.write("Línea 1");\n    bw.newLine();\n    bw.write("Línea 2");\n}', hint: 'BufferedWriter.write() escribe texto. newLine() agrega salto de línea.', validation: { requiredKeywords: ['BufferedWriter', 'write'] } },
    { id: 168, lessonId: 38, title: 'Files Lines Stream', description: 'Lee archivo como Stream.', difficulty: 'hard', starterCode: 'import java.nio.file.*;', solution: 'try (Stream<String> lineas = Files.lines(Path.of("file.txt"))) {\n    lineas.filter(l -> l.contains("Java"))\n          .forEach(System.out::println);\n}', hint: 'Files.lines(path) retorna Stream<String> de líneas del archivo.', validation: { requiredKeywords: ['Files.lines', 'Stream'] } },

    // IDs 169-208: EXPERTO (Threads, Patterns, SOLID, TDD)
    // IDs 169-188: Threads y Concurrencia
    { id: 169, lessonId: 39, title: 'Thread Extends', description: 'Crea thread extendiendo Thread.', difficulty: 'medium', starterCode: '', solution: 'public class MiThread extends Thread {\n    public void run() {\n        System.out.println("Ejecutando");\n    }\n}', hint: 'Extiende Thread y sobrescribe run(). Inicia con start().', validation: { requiredKeywords: ['extends', 'Thread', 'run'] } },
    { id: 170, lessonId: 39, title: 'Runnable Interface', description: 'Implementa Runnable.', difficulty: 'medium', starterCode: '', solution: 'public class MiRunnable implements Runnable {\n    public void run() {\n        System.out.println("Ejecutando");\n    }\n}', hint: 'Implementa Runnable y define run(). Crea Thread: new Thread(runnable).start()', validation: { requiredKeywords: ['implements', 'Runnable'] } },
    { id: 171, lessonId: 39, title: 'Thread Start', description: 'Inicia un thread.', difficulty: 'easy', starterCode: 'Thread t = new Thread(() -> System.out.println("Hola"));', solution: 't.start();', hint: 'start() inicia el thread. NO llames run() directamente.', validation: { requiredKeywords: ['start'] } },
    { id: 172, lessonId: 39, title: 'Thread Sleep', description: 'Pausa thread.', difficulty: 'easy', starterCode: '', solution: 'try {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}', hint: 'Thread.sleep(milisegundos) pausa el thread actual.', validation: { requiredKeywords: ['Thread.sleep'] } },
    { id: 173, lessonId: 39, title: 'Thread Join', description: 'Espera a que termine.', difficulty: 'medium', starterCode: 'Thread t = new Thread(() -> {});', solution: 't.start();\ntry {\n    t.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}', hint: 'join() espera a que el thread termine antes de continuar.', validation: { requiredKeywords: ['join'] } },
    { id: 174, lessonId: 40, title: 'Synchronized Method', description: 'Método sincronizado.', difficulty: 'hard', starterCode: 'private int contador = 0;', solution: 'public synchronized void incrementar() {\n    contador++;\n}', hint: 'synchronized evita que múltiples threads ejecuten el método simultáneamente.', validation: { requiredKeywords: ['synchronized'] } },
    { id: 175, lessonId: 40, title: 'Synchronized Block', description: 'Bloque sincronizado.', difficulty: 'hard', starterCode: 'private Object lock = new Object();', solution: 'synchronized (lock) {\n    // código crítico\n}', hint: 'synchronized (objeto) { } sincroniza solo ese bloque.', validation: { requiredKeywords: ['synchronized'] } },
    { id: 176, lessonId: 40, title: 'Volatile Variable', description: 'Variable volátil.', difficulty: 'medium', starterCode: '', solution: 'private volatile boolean activo = true;', hint: 'volatile asegura que todos los threads vean el valor más reciente.', validation: { requiredKeywords: ['volatile'] } },
    { id: 177, lessonId: 40, title: 'AtomicInteger', description: 'Contador atómico.', difficulty: 'medium', starterCode: 'import java.util.concurrent.atomic.*;', solution: 'AtomicInteger contador = new AtomicInteger(0);\ncontador.incrementAndGet();', hint: 'AtomicInteger provee operaciones thread-safe sin synchronized.', validation: { requiredKeywords: ['AtomicInteger'] } },
    { id: 178, lessonId: 41, title: 'ExecutorService', description: 'Pool de threads.', difficulty: 'hard', starterCode: 'import java.util.concurrent.*;', solution: 'ExecutorService executor = Executors.newFixedThreadPool(5);\nexecutor.submit(() -> System.out.println("Tarea"));\nexecutor.shutdown();', hint: 'ExecutorService maneja un pool de threads. Usa shutdown() al terminar.', validation: { requiredKeywords: ['ExecutorService', 'submit'] } },
    { id: 179, lessonId: 41, title: 'Callable Future', description: 'Tarea con retorno.', difficulty: 'hard', starterCode: 'import java.util.concurrent.*;', solution: 'Callable<Integer> tarea = () -> 42;\nFuture<Integer> futuro = executor.submit(tarea);\nint resultado = futuro.get();', hint: 'Callable retorna valor. Future.get() espera y obtiene el resultado.', validation: { requiredKeywords: ['Callable', 'Future', 'get'] } },
    { id: 180, lessonId: 41, title: 'CompletableFuture', description: 'Programación asíncrona.', difficulty: 'hard', starterCode: 'import java.util.concurrent.*;', solution: 'CompletableFuture.supplyAsync(() -> "Hola")\n    .thenApply(s -> s + " Mundo")\n    .thenAccept(System.out::println);', hint: 'CompletableFuture permite encadenar operaciones asíncronas.', validation: { requiredKeywords: ['CompletableFuture', 'thenApply'] } },
    { id: 181, lessonId: 42, title: 'CountDownLatch', description: 'Espera a múltiples threads.', difficulty: 'hard', starterCode: 'import java.util.concurrent.*;', solution: 'CountDownLatch latch = new CountDownLatch(3);\n// En cada thread: latch.countDown();\nlatch.await();', hint: 'CountDownLatch espera hasta que N threads llamen countDown().', validation: { requiredKeywords: ['CountDownLatch', 'await'] } },
    { id: 182, lessonId: 42, title: 'CyclicBarrier', description: 'Punto de sincronización.', difficulty: 'hard', starterCode: 'import java.util.concurrent.*;', solution: 'CyclicBarrier barrier = new CyclicBarrier(3);\n// En cada thread: barrier.await();', hint: 'CyclicBarrier sincroniza N threads en un punto común.', validation: { requiredKeywords: ['CyclicBarrier'] } },
    { id: 183, lessonId: 42, title: 'Semaphore', description: 'Limita acceso concurrente.', difficulty: 'hard', starterCode: 'import java.util.concurrent.*;', solution: 'Semaphore semaphore = new Semaphore(3);\nsemaphore.acquire();\ntry {\n    // código\n} finally {\n    semaphore.release();\n}', hint: 'Semaphore limita cuántos threads pueden acceder simultáneamente.', validation: { requiredKeywords: ['Semaphore', 'acquire', 'release'] } },
    { id: 184, lessonId: 43, title: 'ConcurrentHashMap', description: 'Map thread-safe.', difficulty: 'medium', starterCode: 'import java.util.concurrent.*;', solution: 'ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\nmap.put("clave", 1);', hint: 'ConcurrentHashMap es thread-safe sin sincronizar todo el map.', validation: { requiredKeywords: ['ConcurrentHashMap'] } },
    { id: 185, lessonId: 43, title: 'CopyOnWriteArrayList', description: 'Lista thread-safe.', difficulty: 'medium', starterCode: 'import java.util.concurrent.*;', solution: 'CopyOnWriteArrayList<String> lista = new CopyOnWriteArrayList<>();\nlista.add("elemento");', hint: 'CopyOnWriteArrayList es thread-safe, ideal para más lecturas que escrituras.', validation: { requiredKeywords: ['CopyOnWriteArrayList'] } },
    { id: 186, lessonId: 43, title: 'BlockingQueue', description: 'Cola bloqueante.', difficulty: 'hard', starterCode: 'import java.util.concurrent.*;', solution: 'BlockingQueue<String> cola = new ArrayBlockingQueue<>(10);\ncola.put("elemento");\nString item = cola.take();', hint: 'BlockingQueue bloquea si está llena (put) o vacía (take).', validation: { requiredKeywords: ['BlockingQueue', 'put', 'take'] } },
    { id: 187, lessonId: 43, title: 'ReentrantLock', description: 'Lock explícito.', difficulty: 'hard', starterCode: 'import java.util.concurrent.locks.*;', solution: 'ReentrantLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    // código crítico\n} finally {\n    lock.unlock();\n}', hint: 'ReentrantLock es más flexible que synchronized. Siempre unlock en finally.', validation: { requiredKeywords: ['ReentrantLock', 'lock', 'unlock'] } },
    { id: 188, lessonId: 43, title: 'ReadWriteLock', description: 'Lock lectura/escritura.', difficulty: 'hard', starterCode: 'import java.util.concurrent.locks.*;', solution: 'ReadWriteLock rwLock = new ReentrantReadWriteLock();\nrwLock.readLock().lock();\ntry {\n    // lectura\n} finally {\n    rwLock.readLock().unlock();\n}', hint: 'ReadWriteLock permite múltiples lectores o un escritor.', validation: { requiredKeywords: ['ReadWriteLock', 'readLock'] } },

    // IDs 189-208: Patterns, SOLID, TDD
    { id: 189, lessonId: 44, title: 'Singleton Pattern', description: 'Instancia única.', difficulty: 'hard', starterCode: '', solution: 'public class Singleton {\n    private static Singleton instancia;\n    private Singleton() {}\n    public static Singleton getInstancia() {\n        if (instancia == null) {\n            instancia = new Singleton();\n        }\n        return instancia;\n    }\n}', hint: 'Constructor privado + método estático que retorna la única instancia.', validation: { requiredKeywords: ['private', 'static'] } },
    { id: 190, lessonId: 44, title: 'Factory Pattern', description: 'Fábrica de objetos.', difficulty: 'hard', starterCode: '', solution: 'public class AnimalFactory {\n    public static Animal crear(String tipo) {\n        if (tipo.equals("perro")) return new Perro();\n        if (tipo.equals("gato")) return new Gato();\n        return null;\n    }\n}', hint: 'Factory encapsula la creación de objetos según parámetros.', validation: { requiredKeywords: ['static', 'return'] } },
    { id: 191, lessonId: 44, title: 'Builder Pattern', description: 'Constructor fluido.', difficulty: 'hard', starterCode: '', solution: 'public class Persona {\n    private String nombre;\n    private int edad;\n    public static class Builder {\n        private Persona p = new Persona();\n        public Builder nombre(String n) {\n            p.nombre = n;\n            return this;\n        }\n        public Persona build() { return p; }\n    }\n}', hint: 'Builder permite construir objetos paso a paso con sintaxis fluida.', validation: { requiredKeywords: ['Builder', 'return this'] } },
    { id: 192, lessonId: 45, title: 'Observer Pattern', description: 'Notifica cambios.', difficulty: 'hard', starterCode: '', solution: 'interface Observer {\n    void actualizar(String evento);\n}\nclass Sujeto {\n    private List<Observer> observadores = new ArrayList<>();\n    public void agregar(Observer o) { observadores.add(o); }\n    public void notificar(String evento) {\n        observadores.forEach(o -> o.actualizar(evento));\n    }\n}', hint: 'Observer: sujeto notifica a múltiples observadores cuando cambia.', validation: { requiredKeywords: ['interface', 'forEach'] } },
    { id: 193, lessonId: 45, title: 'Strategy Pattern', description: 'Algoritmo intercambiable.', difficulty: 'hard', starterCode: '', solution: 'interface Estrategia {\n    int calcular(int a, int b);\n}\nclass Suma implements Estrategia {\n    public int calcular(int a, int b) { return a + b; }\n}\nclass Contexto {\n    private Estrategia estrategia;\n    public void setEstrategia(Estrategia e) { estrategia = e; }\n}', hint: 'Strategy permite cambiar el algoritmo en tiempo de ejecución.', validation: { requiredKeywords: ['interface', 'implements'] } },
    { id: 194, lessonId: 45, title: 'Decorator Pattern', description: 'Añade funcionalidad.', difficulty: 'hard', starterCode: '', solution: 'interface Componente {\n    String operar();\n}\nclass Decorador implements Componente {\n    private Componente componente;\n    public Decorador(Componente c) { componente = c; }\n    public String operar() {\n        return "Decorado: " + componente.operar();\n    }\n}', hint: 'Decorator envuelve un objeto para añadir funcionalidad.', validation: { requiredKeywords: ['implements', 'private'] } },
    { id: 195, lessonId: 46, title: 'SRP - Single Responsibility', description: 'Una responsabilidad.', difficulty: 'medium', starterCode: '', solution: '// Mal: clase con múltiples responsabilidades\n// Bien: separar en clases específicas\nclass Usuario { }\nclass UsuarioRepositorio { }\nclass UsuarioValidator { }', hint: 'SRP: cada clase debe tener una sola razón para cambiar.', validation: { requiredKeywords: ['class'] } },
    { id: 196, lessonId: 46, title: 'OCP - Open/Closed', description: 'Abierto/cerrado.', difficulty: 'hard', starterCode: '', solution: '// Abierto para extensión, cerrado para modificación\nabstract class Forma {\n    abstract double area();\n}\nclass Circulo extends Forma {\n    double radio;\n    double area() { return Math.PI * radio * radio; }\n}', hint: 'OCP: extender comportamiento sin modificar código existente.', validation: { requiredKeywords: ['abstract', 'extends'] } },
    { id: 197, lessonId: 46, title: 'LSP - Liskov Substitution', description: 'Sustitución de Liskov.', difficulty: 'hard', starterCode: '', solution: '// Subtipos deben ser sustituibles por su tipo base\nclass Ave {\n    void volar() { }\n}\n// Mal: Pinguino no puede volar\n// Bien: separar en AveVoladora y AveNoVoladora', hint: 'LSP: los subtipos deben cumplir el contrato del tipo base.', validation: { requiredKeywords: ['class'] } },
    { id: 198, lessonId: 47, title: 'ISP - Interface Segregation', description: 'Segregación de interfaces.', difficulty: 'medium', starterCode: '', solution: '// Mal: interfaz grande\n// Bien: interfaces pequeñas y específicas\ninterface Imprimible {\n    void imprimir();\n}\ninterface Escaneable {\n    void escanear();\n}', hint: 'ISP: muchas interfaces específicas mejor que una general.', validation: { requiredKeywords: ['interface'] } },
    { id: 199, lessonId: 47, title: 'DIP - Dependency Inversion', description: 'Inversión de dependencias.', difficulty: 'hard', starterCode: '', solution: '// Depender de abstracciones, no de concreciones\ninterface Repositorio {\n    void guardar();\n}\nclass Servicio {\n    private Repositorio repo;\n    public Servicio(Repositorio r) { repo = r; }\n}', hint: 'DIP: clases de alto nivel no deben depender de clases de bajo nivel.', validation: { requiredKeywords: ['interface', 'private'] } },
    { id: 200, lessonId: 48, title: 'JUnit Test', description: 'Test unitario básico.', difficulty: 'medium', starterCode: 'import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;', solution: '@Test\nvoid testSuma() {\n    int resultado = 2 + 2;\n    assertEquals(4, resultado);\n}', hint: '@Test marca un método de prueba. assertEquals verifica igualdad.', validation: { requiredKeywords: ['@Test', 'assertEquals'] } },
    { id: 201, lessonId: 48, title: 'JUnit BeforeEach', description: 'Setup antes de cada test.', difficulty: 'medium', starterCode: 'import org.junit.jupiter.api.BeforeEach;', solution: '@BeforeEach\nvoid setUp() {\n    // inicialización\n}', hint: '@BeforeEach se ejecuta antes de cada test.', validation: { requiredKeywords: ['@BeforeEach'] } },
    { id: 202, lessonId: 48, title: 'JUnit AssertThrows', description: 'Verifica excepción.', difficulty: 'hard', starterCode: 'import static org.junit.jupiter.api.Assertions.*;', solution: '@Test\nvoid testExcepcion() {\n    assertThrows(IllegalArgumentException.class, () -> {\n        throw new IllegalArgumentException();\n    });\n}', hint: 'assertThrows verifica que se lance una excepción específica.', validation: { requiredKeywords: ['assertThrows'] } },
    { id: 203, lessonId: 49, title: 'Mockito Mock', description: 'Crea mock.', difficulty: 'hard', starterCode: 'import static org.mockito.Mockito.*;', solution: 'Repositorio mockRepo = mock(Repositorio.class);\nwhen(mockRepo.obtener()).thenReturn("dato");', hint: 'mock() crea un objeto simulado. when().thenReturn() define comportamiento.', validation: { requiredKeywords: ['mock', 'when', 'thenReturn'] } },
    { id: 204, lessonId: 49, title: 'Mockito Verify', description: 'Verifica llamadas.', difficulty: 'medium', starterCode: 'import static org.mockito.Mockito.*;', solution: 'Repositorio mockRepo = mock(Repositorio.class);\nmockRepo.guardar();\nverify(mockRepo).guardar();', hint: 'verify() comprueba que un método fue llamado.', validation: { requiredKeywords: ['verify'] } },
    { id: 205, lessonId: 49, title: 'TDD Red-Green-Refactor', description: 'Ciclo TDD.', difficulty: 'hard', starterCode: '', solution: '// 1. Red: escribe test que falla\n@Test void testFalla() { assertEquals(5, suma(2,2)); }\n// 2. Green: implementa mínimo para pasar\nint suma(int a, int b) { return a + b; }\n// 3. Refactor: mejora el código', hint: 'TDD: primero test (rojo), luego código (verde), finalmente refactorizar.', validation: { requiredKeywords: ['@Test'] } },
    { id: 206, lessonId: 50, title: 'AssertJ Fluent', description: 'Aserciones fluidas.', difficulty: 'medium', starterCode: 'import static org.assertj.core.api.Assertions.*;', solution: 'String texto = "Hola";\nassertThat(texto)\n    .isNotNull()\n    .startsWith("H")\n    .hasSize(4);', hint: 'AssertJ permite aserciones encadenadas y legibles.', validation: { requiredKeywords: ['assertThat'] } },
    { id: 207, lessonId: 50, title: 'Parametrized Test', description: 'Test con parámetros.', difficulty: 'hard', starterCode: 'import org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;', solution: '@ParameterizedTest\n@ValueSource(ints = {1, 2, 3})\nvoid testMultiple(int numero) {\n    assertTrue(numero > 0);\n}', hint: '@ParameterizedTest ejecuta el test con múltiples valores.', validation: { requiredKeywords: ['@ParameterizedTest', '@ValueSource'] } },
    { id: 208, lessonId: 50, title: 'Test Coverage', description: 'Cobertura de código.', difficulty: 'medium', starterCode: '', solution: '// Usa herramientas como JaCoCo\n// Objetivo: >80% de cobertura\n// Cubre: líneas, ramas, métodos\n// mvn test jacoco:report', hint: 'Cobertura mide qué porcentaje del código es ejecutado por tests.', validation: { requiredKeywords: ['test'] } }
];

const evaluationsData = {
    beginner: {
        title: 'Evaluación: Nivel Principiante',
        passingScore: 70,
        questions: [
            { id: 1, question: '¿Tipo para enteros?', options: ['int', 'float', 'String', 'boolean'], correct: 0 },
            { id: 2, question: '¿Índice inicial array?', options: ['1', '0', '-1', 'n'], correct: 1 },
            { id: 3, question: '¿Operador AND?', options: ['&', '&&', 'AND', 'and'], correct: 1 },
            { id: 4, question: '¿Salir de bucle?', options: ['exit', 'break', 'stop', 'end'], correct: 1 },
            { id: 5, question: '¿String es primitivo?', options: ['Sí', 'No'], correct: 1 }
        ]
    },
    intermediate: {
        title: 'Evaluación: Nivel Intermedio',
        passingScore: 70,
        questions: [
            { id: 1, question: '¿POO significa?', options: ['Prog. Orientada a Objetos', 'Proc. Opt. Online'], correct: 0 },
            { id: 2, question: '¿ प्राइवेट (private) hace?', options: ['Oculta atributo', 'Hace público'], correct: 0 },
            { id: 3, question: '¿extends sirve para?', options: ['Interfazar', 'Heredar'], correct: 1 },
            { id: 4, question: '¿ArrayList es?', options: ['Fijo', 'Dinámico'], correct: 1 },
            { id: 5, question: '¿Map guarda?', options: ['Lista', 'Clave-Valor'], correct: 1 }
        ]
    },
    advanced: {
        title: 'Evaluación: Nivel Avanzado',
        passingScore: 75,
        questions: [
            { id: 1, question: '¿Lambda es?', options: ['Función anónima', 'Error'], correct: 0 },
            { id: 2, question: '¿filter() es de?', options: ['Stream', 'System'], correct: 0 },
            { id: 3, question: '¿Optional evita?', options: ['Bugs', 'NullPointerException'], correct: 1 },
            { id: 4, question: '¿try-catch maneja?', options: ['Compilación', 'Excepciones'], correct: 1 },
            { id: 5, question: '¿BufferedReader es?', options: ['Lento', 'Rápido (buffer)'], correct: 1 }
        ]
    },
    expert: {
        title: 'Evaluación: Nivel Experto',
        passingScore: 80,
        questions: [
            { id: 1, question: '¿Singleton asegura?', options: ['Instancia única', 'Múltiples'], correct: 0 },
            { id: 2, question: '¿SOLID: S es?', options: ['Single Responsibility', 'Simple'], correct: 0 },
            { id: 3, question: '¿Synchronized previene?', options: ['Lentitud', 'Race conditions'], correct: 1 },
            { id: 4, question: '¿TDD empieza con?', options: ['Código', 'Test'], correct: 1 },
            { id: 5, question: '¿Factory es?', options: ['Patrón creación', 'Patrón conducta'], correct: 0 }
        ]
    },
    final: {
        title: 'Evaluación Final - Certificación JavaMaster',
        passingScore: 85,
        questions: [
            { id: 1, question: '¿JVM es?', options: ['Máquina Virtual', 'Compilador'], correct: 0 },
            { id: 2, question: '¿Java es?', options: ['Compilado', 'Interpretado', 'Ambos (Bytecode)'], correct: 2 }
        ]
    }
};

// Exportar datos
if (typeof module !== 'undefined') {
    module.exports = { exercisesData, evaluationsData };
}
